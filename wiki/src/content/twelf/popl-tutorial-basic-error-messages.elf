%%! title: "POPL Tutorial/Basic error messages"

%{!
#
# How Twelf checks assertions

Twelf proves a totality assertion for a type family such as
``mult`` by checking several properties.  These properties, taken
together, constitute a proof by induction on canonical forms that the
type family defines a total relation.

#
#
# Running Example

We'll start from the following code:

&lt;twelf import="base"&gt;
nat : type.  
zero : nat.
succ : nat -&gt; nat.

add : nat -&gt; nat -&gt; nat -&gt; type.
%mode add +M +N -P.

add/z : add zero N N.
add/s : add (succ M) N (succ P) 
	 &lt;- add M N P.

%worlds () (add _ _ _).
%total M (add M _ _).
&lt;/twelf&gt;

&lt;twelf import="base" export="mult"&gt;
mult : nat -&gt; nat -&gt; nat -&gt; type.
%mode mult +M +N -P.

mult/z : mult zero N zero.
mult/s : mult (succ M) N P'
	  &lt;- mult M N P
	  &lt;- add N P P'.
&lt;/twelf&gt;

#
#
# Mode

Twelf checks that each constant inhabiting the type family is
_well-moded_.  Roughly, this means that the inputs to the conclusion
of a constant determine the inputs of the first premise, and that these
together with the outputs of the first premise determine the inputs of
the second premise, and so on, until the outputs of all the premises
determine the outputs of the conclusion.
For example, the constant
&lt;twelf import="mult" discard=true&gt;
mult/s : mult (succ M) N P'
	  &lt;- mult M N P
	  &lt;- add N P P'.
&lt;/twelf&gt;

has mode ``+M +N -P`` because the input ``M`` and ``N``
in the conclusion determine the inputs of the premise, and the
``P`` output by the premise determines the first input to the second
premise (add), and the output of that determines the conclusion.  
On the other hand, a constant

&lt;twelf import="mult" check=decl discard=true&gt;
mult/bad-mode-output : mult zero N P.
&lt;/twelf&gt;
is not well-moded---the output ``P`` is not determined by the
inputs.  Similarly, 
&lt;twelf import="mult" check=decl discard=true&gt;
mult/bad-mode-input : mult (succ M) N zero
 		       &lt;- mult M Q P.
&lt;/twelf&gt; 
is not well-moded---the second input to the premise is not determined
by the inputs of the conclusion.

Note that subgoal order matters: 

&lt;twelf import="mult" check=decl discard=true&gt;
mult/s : mult (succ M) N Q
	  &lt;- add P N Q
	  &lt;- mult M N P.
&lt;/twelf&gt;

The premises are mode-checked in order; the outputs from one subgoal are
consider ground in subsequent premises.

#
#
# Worlds

Twelf checks that each constant inhabiting the type family obeys the
worlds declaration.  Because we are only proving theorems about closed
terms right now, we will not run across any problems with world
checks.  

#
#
# Termination

Twelf checks that each constant inhabiting the type family obeys the
induction order specified in the ``%total`` declaration.  In each
inductive premise of a constant, the specified induction position must
be a strict subterm of the corresponding argument in the conclusion.
For example, the constant

&lt;twelf import="mult" discard=true&gt;
mult/s : mult (s M) N Q
	  &lt;- mult M N P
	  &lt;- add P N Q.
&lt;/twelf&gt;
obeys the induction order ``M`` specified in the above totality
assertion because the term ``M`` is a strict subterm of the term
``(s M)``.

Recuring on exactly the same term is obviously a termination error:
&lt;twelf import="mult" check=decl discard=true&gt;
mult/bad-termination-1 : mult M N P
			  &lt;- mult M N P.
%total M (mult M _ _).
&lt;/twelf&gt;

As is recuring on an entirely unrelated argumenet:

&lt;twelf import="mult" check=decl discard=true&gt;
mult/bad-termination-2 : mult M N P
			  &lt;- mult N N P.
%total M (mult M _ _).
&lt;/twelf&gt;

For example Twelf would not accept the totality of ``mult``
if ``N`` were used as the induction order&mdash;the same term
``N`` in the conclusion of this constant appears in the premise:

&lt;twelf import="mult" check=decl discard=true&gt;
%total N (mult _ N _).
&lt;/twelf&gt;

In addition to the subterm ordering on a single argument, Twelf supports
[mutual induction](/wiki/mutual-induction/) and [output freeness](/wiki/output-freeness/): a type family will not be judged total if you
constrain the outputs of any premise at all in this manner.

#
#
# Input coverage

Mode, worlds, termination, and output coverage ensure that each constant
really does cover the part of the relation indicated by its conclusion.
For example, if ``mult`` passes these four checks, we know that
``mult/z`` and ``mult/s`` cover ``(zero, N, _)`` and ``(succ M,
N, _)``, respectively.  What else is necessary to know that
``mult`` defines a total relation?  We need to know that all the
constants inhabiting ``mult``, taken together, cover all of the
inputs.  Input coverage checks exactly this.

For example, if we forgot ``mult/z``, input coverage for
``mult`` would fail.  For example:

&lt;twelf import="base" check=decl discard=true&gt;
mult' : nat -&gt; nat -&gt; nat -&gt; type.
%mode mult' +N1 +N2 -X3.

mult'/s : mult' (succ M) N Q
	  &lt;- mult' M N P
	  &lt;- add P N Q.

%worlds () (mult' _ _ _).
%total M (mult' M _ _).
&lt;/twelf&gt;

Here's an analogy that might be helpful: You can think of each constant
of a type as being a clause in an ML pattern matching declaration.  Then
input coverage is like the exhaustiveness checker for pattern matching.

Twelf checks input coverage by [%terminates](/wiki/percent-terminates/) and [%covers](/wiki/percent-covers/) to check termination and input coverage independently.

If any constant in a type family fails mode, worlds, or output coverage, then mode, worlds, or totality checking fails for the whole type family.  One could imagine that Twelf instead would just disregard the offending constant: it is possible that the type family as a whole satisfies a totality assertion without that constant, and, in a mathematical sense, adding additional constants never invalidates the fact a totality assertion is true of a family.    The reason Twelf does not work this way is that ``%total`` actually has a more specific meaning, as we discuss in the next section.
!}%
