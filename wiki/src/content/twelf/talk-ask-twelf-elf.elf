%%! title: "Talk:Ask Twelf Elf"

%{!
#
# Archives

* [Talk:Ask Twelf Elf/Archive 1](/wiki/talk-ask-twelf-elf-archive-1/) (October 2006-March 2007)
* [Talk:Ask Twelf Elf/Archive 2](/wiki/talk-ask-twelf-elf-archive-2/) (April 2007-October 2007)

#
# LF representation of complete development

Consider pure lambda terms:

 trm : type.
 lam : (trm -&gt; trm) -&gt; trm.
 app : trm -&gt; trm -&gt; trm.

Tait/Martin-Loef parallel reduction is represented in Frank Pfenning's paper on Church-Rosser as:

 =&gt; : trm -&gt; trm -&gt; type.  %infix none 10 =&gt;.
 pr1_beta : (app (lam M) N) =&gt; M' N'
           &lt;- (\{x:trm\} x =&gt; x -&gt; M x =&gt; M' x)
           &lt;- N =&gt; N'.
 pr1_app  : (app M N) =&gt; (app M' N')
           &lt;- N =&gt; N'
           &lt;- M =&gt; M'.
 pr1_lam  : lam M =&gt; lam M'
           &lt;- (\{x:trm\} x =&gt; x -&gt; M x =&gt; M' x).

I'm not completely satisfied by the explanation in Frank's paper for why the pr1_beta rule has higher-order premise "\{x:trm\} x =&gt; x", but pr1 is reflexive, and that premise seems necessary to prove it.

The complete development relation is informally given by the following rules:

 -----------
   x ==&gt; x

 M ==&gt; M'  N ==&gt; N'
 -----------------  (M is not a lambda)
 (M N) ==&gt; (M' N')

  M ==&gt; N
 --------------
 \x.M ==&gt; \x.N

 M ==&gt; M'  N ==&gt; N'
 ------------------------
 (\x.M) N ==&gt; M'[x::=N']

Informally, ==&gt; is the same as =&gt; except for the side condition "M is not a lambda" on the application rule.  This removes the non-determinism of =&gt; and forces ==&gt; to contract every redex in the input term; ==&gt; goes as far as any =&gt; can.  ==&gt; is a subrelation of =&gt;.

My question is how to represent ==&gt; in LF.  There seem to be two issues: how to represent the side condition (the informal system accepts both applications and variables), and what to do about the higher-order premise "\{x:trm\} x =&gt; x"  (because ==&gt; is not reflexive).

Thanks,
User:Rpollack|Rpollack]] 10:16, 28 February 2008 (EST) Randy


: Hi Randy.  This is a great question.  I've started a tutorial answering it: [Working with higher-order judgements](/wiki/reformulating-languages-to-use-hypothetical-judgements/).  Feel free to discuss the tutorial on its [Talk:Working with higher-order judgements](/wiki/talk-reformulating-languages-to-use-hypothetical-judgements/) if it's at all unclear.  [User:Drl](/wiki/user-drl/) 15:07, 28 February 2008 (EST)

#
# Question Regarding Explicit LF Specification Generation

Question: can Twelf produce a fully explicit LF specification from one that is not fully explicit?  By "fully explicit", I mean one that needs no further term reconstruction (all type parameters are explicitly bound).  Twelf-sml's Print.sgn is close, but doesn't provide explicit (or even original) %solve or %query directives (nor would I expect it to, as that is not the function's purpose).  As a note, Print.sgn places terms declared as infix in head position, which is fine for my use.

The reason I am interested in such functionality is that I want to perform some syntactic analyses of LF specifications.  I would like to use existing Twelf specifications as input, but I don't want to manually make type parameters explicit, nor do I want to reimplement term reconstruction.  However the analyses require fully explicit input.

Thanks!

#
# Queries with non-empty contexts?

Is it possible to use pi-types in the in the goals for %query? The example below shows what I'm trying to do. Since the workaround using a dummy type family works it does not seem to be an inherent limitation in the logic programming engine...
This is Twelf 1.5R1, Mar 8, 2005 (tabling).

&lt;twelf&gt;
exp : type.

app : exp -&gt; exp -&gt; exp.
lam : (exp -&gt; exp) -&gt; exp.

tp : type.

unit : tp.
arrow : tp -&gt; tp -&gt; tp.

of : exp -&gt; tp -&gt; type.

of-app : (of E1 (arrow T1 T2)) -&gt; (of E2 T1) -&gt; of (app E1 E2) T2.
of-lam : of (lam ([x] Body x)) (arrow T1 T2)
	  &lt;- \{x : exp\} \{Hx : of x T1\} of (Body x) T2.

%% finds a solution as expected:
%query 1 1 
  of (lam ([x] (lam ([y] (app x y))))) T.

%% "found 0" solutions.
%query 1 1
  \{x : exp\} \{Hx : of x (arrow unit unit)\}
  \{y : exp\} \{Hy : of y unit\}
    of (app x y) T.

%% This works, however.
dummy  : tp -&gt; type.
dummy1 : dummy T 
	  &lt;- \{x : exp\} \{Hx : of x (arrow unit unit)\}
	     \{y : exp\} \{Hy : of y unit\}
	     of (app x y) T.
%query 1 1 dummy T.
&lt;/twelf&gt;

#
# normalization theorems?

Hello, 

I was wandering if the meta logic of Twelf can somehow express (weak or strong) 
normalization properties.  Or if it currently cannot, what would be a natural extension 
of this meta logic suitable for this?

Thanks, 
 Andrei Popescu

: See [Hereditary substitution for the STLC](/wiki/hereditary-substitution-for-the-stlc/) for an example of normalization of the simply-typed lambda calculus. The common way of stating theorems in Twelf does not extend to logical relations arguments defined by induction on a type; however, see http://www.twelf.org/slr/ Structural Logical Relations]] for a slightly different way to encode these in Twelf (as it currently exists).
— [User:rsimmons](/wiki/user-rsimmons/) (and his [User talk:rsimmons](/wiki/user-talk-rsimmons/)) 02:26, 12 October 2008 (EDT)

#
# More exercises.

Dear Elves,

    the Twelf web-page is great to learn about it, but I wish you guys could
post more exercises with answers. It makes it easier to teach teach in the
classroom, and it helps self-learners like me. I have coded a simple
exercise using even/odd numbers, and I am sending it to you guys, so that
maybe you could post it at:
http://twelf.plparty.org/wiki/Proving_metatheorems:Natural_numbers:_Answers_to_exercises

All the best,

Special:Contributions/71.106.190.54|71.106.190.54]] 18:25, 23 October 2008 (EDT)Fernando

----------------------------------------------------------------------------

We have already seen how to proof a theorem showing that the addition of
two even numbers produces an even number. This theorem can be stated as
follows:

sum-evens : even N1 -&gt; even N2 -&gt; plus N1 N2 N3 -&gt; even N3 -&gt; type.
%mode sum-evens +D1 +D2 +D3 -D4.

The proof of our theorem is a simple case analysis on the possible
derivations of even numbers:

sez : sum-evens even-z DevenN2 plus-z DevenN2.

ses : sum-evens 
       (even-s EvenN1)
       EvenN2
       (plus-s (plus-s PlusN1N2N3))
       (even-s EvenN3)
       &lt;- sum-evens EvenN1 EvenN2 PlusN1N2N3 EvenN3.

%worlds () (sum-evens _ _ _ _).
%total D (sum-evens D _ _ _).

In what follows, you will be asked to write proofs for three similar
theorems. Exercise 2 defines lemmas that will be useful in the
proofs in Exercise 3.

Exercise 1: define the odd numbers. Start with one, e.g, s z as your base
case, and define the other odd numbers inductively.

Answer: ==================================================================
% Odd natural numbers:
odd   : nat -&gt; type.
odd-1 : odd (s z).
odd-s : odd N -&gt; odd (s (s N)).
Answer: ==================================================================

Exercise 2: now that we have defined the odd numbers, you are asked to
prove a simple relation between odd and even numbers. First, state and
prove a Theorem succ-even that shows that the successor of an even number
is an odd number. After that, state and prove a Theorem succ-odd that
shows that the successor of an odd number is an even number.

Answer: ==================================================================
succ-even : even N -&gt; odd (s N) -&gt; type.
%mode succ-even +D1 -D2.

sez : succ-even even-z odd-1.

ses : succ-even (even-s EvenA) (odd-s OddA)
       &lt;- succ-even EvenA OddA.

%worlds () (succ-even _ _).
%total D (succ-even D _).

succ-odd : odd N -&gt; even (s N) -&gt; type.
%mode succ-odd +D1 -D2.

so1 : succ-odd odd-1 (even-s even-z).

sos : succ-odd (odd-s OddA) (even-s EvenA)
       &lt;- succ-odd OddA EvenA.

%worlds () (succ-odd _ _).
%total D (succ-odd D _).
Answer: ==================================================================

Exercise 3: now we would like to prove theorems that state the relation
between sums of odd and even numbers, and between odd numbers.

(3a) First, state and prove the theorem sum-even-odd that shows that the sum
of an even and an odd number results in an odd number:

Answer: ==================================================================
sum-even-odd : even N1 -&gt; odd N2 -&gt; plus N1 N2 N3 -&gt; odd N3 -&gt; type.
%mode sum-even-odd +D1 +D2 +D3 -D4.

seoz : sum-even-odd even-z OddN2 plus-z OddN2.

seos : sum-even-odd
       (even-s EvenN1)
       OddN2
       (plus-s (plus-s PlusN1N2N3))
       (odd-s OddN3)
       &lt;- sum-even-odd EvenN1 OddN2 PlusN1N2N3 OddN3.

%worlds () (sum-even-odd _ _ _ _).
%total D (sum-even-odd D _ _ _).
Answer: ==================================================================

(3b) State and prove a theorem sum-odd-even that shows that the sum of an
odd plus an even number produces an odd number:

Answer: ==================================================================
sum-odd-even : odd N1 -&gt; even N2 -&gt; plus N1 N2 N3 -&gt; odd N3 -&gt; type.
%mode sum-odd-even +D1 +D2 +D3 -D4.

soe1 : sum-odd-even odd-1 EvenN2 _ OddN3
	&lt;- succ-even EvenN2 OddN3.

soes : sum-odd-even
	(odd-s OddN1)
	EvenN2
	(plus-s (plus-s PlusN1N2N3))
	(odd-s OddN3)
	&lt;- sum-odd-even OddN1 EvenN2 PlusN1N2N3 OddN3.

%worlds () (sum-odd-even _ _ _ _).
%total D (sum-odd-even D _ _ _).
Answer: ==================================================================

(3c) Finally, state and prove a theorem sum-odds that shows that the sum
of two odd numbers produces an even number:

Answer: ==================================================================
sum-odds : odd N1 -&gt; odd N2 -&gt; plus N1 N2 N3 -&gt; even N3 -&gt; type.
%mode sum-odds +D1 +D2 +D3 -D4.

soz : sum-odds odd-1 OddN2 _ EvenN3
       &lt;- succ-odd OddN2 EvenN3.

sos : sum-odds (odd-s OddN1) OddN2 (plus-s (plus-s PlusN1N2N3)) (even-s EvenN3)
       &lt;- sum-odds OddN1 OddN2 PlusN1N2N3 EvenN3.

%worlds () (sum-odds _ _ _ _).
%total D (sum-odds D _ _ _).
Answer: ==================================================================

#
# %Undefine

Is there a way to do the 'opposite' of %abbrev in Twelf? 
Consider the following definition of 'and':

  and : o -&gt; o -&gt; o =
    [A][B] forall [C] (A imp B imp C) imp C.
  and_i   : pf A -&gt; pf B -&gt; pf (A and B) = ...
  and_e1  : pf (A and B) -&gt; pf A = ...
  and_e2  : pf (A and B) -&gt; pf B = ...

How could I prevent Twelf from expanding 'and' after this point?
I'm working on an automated prover based on Felty's and Appel's ideas and
unnecessary expansion causes the prover to terminate with unintelligible output,
whenever it fails to prove something. (The prover outputs all unfinished goals.)

:: Hey! Feel free to contact us by email, I can give you a bit of advice depending on what your precise goals are. I think in Twelf the way of doing this is probably ``[%clause](/wiki/percent-clause/)``, but it turns out to be a bit messy to do things that way. I discuss two styles of Appel & Felty style proving in the article on [tactical theorem proving](/wiki/tactical-theorem-proving/). — [User:rsimmons](/wiki/user-rsimmons/) (and his [User talk:rsimmons](/wiki/user-talk-rsimmons/)) 09:56, 2 February 2009 (EST)

#
# hypothetical judgments vs judgments with premises

I am having trouble understanding when hypothetical judgments can be used in place of judgments with premises.
In the code segment below, the two queries at the bottom look logically equivalent, but Twelf only finds a solution for one of the queries.
Any help is appreciated.
Thanks,
--Special:Contributions/128.119.240.174|128.119.240.174]] 11:04, 9 February 2009 (EST)
John

&lt;twelf&gt;

% Define elements
elem : type.
i : elem.
j : elem.

% Define lists
list : type.
nil : list.
, : elem -&gt; list -&gt; list. %infix right 10 ,.

% neq = not equal relation judging when two elements are not equal
neq : elem -&gt; elem -&gt; type.

% notin A L = A is an element that is not in L
notin : elem -&gt; list -&gt; type.
notin/nil   : notin A nil.
notin/skip  : notin A (B, L)
			  &lt;- neq A B
			  &lt;- notin A L.

sample-list : list = j , j , nil.
% Solution found for this query:
%query 1 1 Y : notin i sample-list &lt;- neq i j.

% Solution NOT found this query:
%query 1 1 Z : \{x:neq i j\} notin i sample-list.

&lt;/twelf&gt;

#
# proving things about an intensional property

I find it easy to prove a Twelf metatheorem that an extensional definiton satsifies certain intensional properties.
For example, suppose I define some relation P |- Q using extensional rules (like a sequent calculus).
Suppose now I have a semantics s |= P that means that P is true in situation s.  Now I want to talk
about an intensional property P |= Q, which says forall s such that s |= P, we have s |= Q.
In Twelf, it is natural to write a meta theorem that says forall s such that s |= P and P |- Q, then s |= Q.
In other words, we can express the idea that the extensional relation satisfies the intensional relation.

But now I want to prove some theorems such as P |= Q and Q |= R implies Q |= R.
But I don't know how to express this idea in Twelf.  This question must come up a lot.
Can you point me to a tutorial on it?

[User:Boyland](/wiki/user-boyland/) 16:29, 27 February 2009 (EST)

: I'm not sure I know a way to express this without using a heavy structural-logical-relations-style formulation - it's outside of the forall-exists fragment if you expand the definitions. However, it seems that whenever such a property would be _needed_ in a proof you could acquire it by calling the theorem you described twice - is that not the case? — [User:rsimmons](/wiki/user-rsimmons/) (and his [User talk:rsimmons](/wiki/user-talk-rsimmons/)) 22:36, 1 March 2009 (EST)

:: Yes, if I needed transitivity, it can easily be proved at that point. But I'm going to try to prove a host of theorems like A * B |= B * A  (which can be rephrased with |=) and P |= Q, A |= B implies P * A |= Q * B which cannot be easily rephrased.  Can you point me to the cleanest tutorial on logical relations? [User:Boyland](/wiki/user-boyland/) 13:57, 2 March 2009 (EST)

: An interesting side-note.  I tried phrasing |= in Twelf anyway using
&lt;twelf&gt;
implies : term -&gt; term -&gt; type.

implies/def : (\{s\} models s P -&gt; models s Q) -&gt; implies P Q.
&lt;/twelf&gt;
This works great for proving transitivity, but is terrible at proving anything else, like A * B |= B * A. [User:Boyland](/wiki/user-boyland/) 13:57, 2 March 2009 (EST)

:: It seems like you want a computational function, not an LF function; I'm working on a framework that would provide you with that: [http://www.cs.cmu.edu/~rwh/papers/unibind/short.pdf A Universe of Binding and Computation].  Would "mixed datatypes" in the sense of the introduction of that paper be useful in your definition of "|="? [User:Drl](/wiki/user-drl/) 19:33, 3 March 2009 (EST)

::: Yes, that is what I need, but it seems not to be part of Twelf! [User:Boyland](/wiki/user-boyland/) 22:25, 7 July 2009 (EDT)

: A further update: I started working through the structural logical relations paper and got the impression I needed to design a simple sequent calculus with atomic rules specific to my application and then prove a cut elimination theorem (or cut admissibility theorem).  I did this (and learned a bit more about cut elimination).  But then when I went further, I think I bumped into a show stopper: the relation P |= Q includes universal quantification over heaps and thus with the normal Twelf  way, hypothetical heaps. The problem is that I have a lot of theorems about heaps (e.g., associativity of heap addition) and as far as I can understand, none of them will work if there might be a hypothetical heap in the context.

: To be a little more concrete: suppose one has a nat type and a plus operation with an effectiveness lemma.  Suppose one further has a simple assertion language expressed in a sequent calculus with an atomic rule (form/plus N1 N2 N3) defined as true precisely when (plus N1 N2 N3) is true.  Now if I try to form the assertion:forall N exists N2:(form/plus N N N2) , then I cannot use my effectiveness lemma, right?  The "solution" is to put every single theorem one needs about nats into the context whenever one has a hypothetical nat.  Is this right?  If so, this approach seems useless.

: I guess the problem is that Twelf doesn't "know" that this hypothetical value must be of one of the declared forms (z or s) if it is ever substituted.  I wonder why Twelf doesn't have this ability. Would it make the logic unsound? [User:Boyland](/wiki/user-boyland/) 22:25, 7 July 2009 (EDT)

::I tried this out in Twelf and got the expected worlds violation:(this code requires my nat.elf "library" signature)
&lt;twelf&gt;
form : type.

form/plus : nat -&gt; nat -&gt; nat -&gt; form.

form/forall : (nat -&gt; form) -&gt; form.

form/exists : (nat -&gt; form) -&gt; form.


hyp   : form -&gt; type.

conc  : form -&gt; type.


conc/plus : plus N1 N2 N3 -&gt; conc (form/plus N1 N2 N3).

ax    : hyp F -&gt; conc F.

allr  : (\{n:nat\} conc (F n)) -&gt; conc (form/forall F).

alll  : \{n:nat\} (hyp (F n) -&gt; conc H) -&gt; hyp (form/forall F) -&gt; conc H.

somer : \{n:nat\} (conc (F n)) -&gt; conc (form/exists F).

somel : (\{n:nat\} (hyp (F n) -&gt; conc H)) -&gt; hyp (form/exists F) -&gt; conc H.


%theorem assert-exists-double :
	forall \{N\}
	exists \{AE: (conc (form/exists ([n] (form/plus N N n))))\}
        true.

- : assert-exists-double N (somer N2 (conc/plus P))
    &lt;- plus-total P.

%worlds () (assert-exists-double _ _).
%total \{ \} (assert-exists-double _ _).   % Just fine.


%theorem assert-exists-double2 :
	exists \{AE: (conc (form/forall ([n] (form/exists ([n2] (form/plus n n n2))))))\}
        true.

- : assert-exists-double2 
     (allr ([n:nat] (somer (N2 n) (conc/plus (P n)))))
    &lt;- (\{n:nat\} plus-total* n n (N2 n) (P n)).

%worlds () (assert-exists-double2 _).   %  NB: world violation!
%total \{ \} (assert-exists-double2 _).
&lt;/twelf&gt;
::: It makes sense that this is rejected in Twelf, because the "function" (N2 n) has no ability to be expressed in LF.  But this does mean that the limitation of Twelf's metatheorems is a live issue: not put to rest by the "Structural Logical Relations" paper.

: After some discussion with Karl Crary, it seems that the best solution is to define an empty relation, define some trustme "metatheorems" that express the desired properties and then prove all theorems in a context (worlds) with a variable of the empty relation.  This ensures that Twelf will not split on the empty relation. [User:Boyland](/wiki/user-boyland/) 15:26, 20 February 2010 (EST)

#
# Negative premises

I'm attempting to express the operational semantics of concurrent calculi like CCS in Twelf, but the inference rules for these calculi often require negative premises. I was wondering if such a thing is possible in Twelf.

Below is my specification for (part of) a CCS-like language without the rule for hiding actions. Here, 'trans P1 A P2' represents a transition from P1 to P2 labelled with A.

&lt;twelf&gt;
label : type.
proc : type.

a : label.
b : label.
c : label.
d : label.
0 : proc.

, : label -&gt; proc -&gt; proc.
+ : proc -&gt; proc -&gt; proc.
| : proc -&gt; proc -&gt; proc.

%infix right 12 ,.
%infix left 10 +.
%infix left 9 |.

trans : proc -&gt; label -&gt; proc -&gt; type.

pref-rule : \{A:label\} \{P:proc\} trans (A , P) A P.
suml-rule : \{A:label\} \{P1:proc\} \{Q:proc\} \{P2:proc\} trans P1 A P2 -&gt; trans (P1 + Q) A P2.
sumr-rule : \{A:label\} \{P1:proc\} \{Q:proc\} \{P2:proc\} trans P1 A P2 -&gt; trans (Q + P1) A P2.
parl-rule : \{A:label\} \{P1:proc\} \{Q:proc\} \{P2:proc\} trans P1 A P2 -&gt; trans (P1 | Q) A (P2 | Q).
parr-rule : \{A:label\} \{P1:proc\} \{Q:proc\} \{P2:proc\} trans P1 A P2 -&gt; trans (Q | P1) A (Q | P2).
&lt;/twelf&gt;

In order to encode the rule for hiding, I would need something like this:

&lt;twelf&gt;
\ : proc -&gt; label -&gt; proc.  %infix left 11.

hide-rule: \{A:label\} \{P1:proc\} \{P2:proc\} trans P1 A P2 -&gt; A != B -&gt; trans (P1 \ B) A (P2 \ B)
&lt;/twelf&gt;

where A != B is meant to be inequality of labels. Is there a simple way of encoding such negative premise?

:: Unfortunately, no: you'll have to define the != judgement inductively yourself, by giving a case for each pair of non-equal labels (and then you may need to prove that A != A is a contradiction).  But we're working on [http://www.cs.cmu.edu/~drl/pubs/lh09unibind/lh09unibind.pdf a framework where you could express this directly], so thanks for the example!  [User:Drl](/wiki/user-drl/) 14:28, 4 May 2009 (EDT)

#
# Coverage checking

I am having trouble understanding the behavior of the coverage checker on this example, a snippet of a dependently-typed functional language encoding:
&lt;code&gt;
tp : type.

vl : tp -&gt; type.	 % values
tm : tp -&gt; type.	 % terms
obs : tp -&gt; tp -&gt; type.	 % "observations"

! : vl A -&gt; tm A.
  %prefix 90 !.
cut: obs A B -&gt; vl A -&gt; tm B.

%% body is a functional relation, defining each value
%% as a "map from observations to terms".
body : vl A -&gt; obs A X -&gt; tm X -&gt; type.
%mode body +V +C -E.

%% We introduce one kind of type, pi (and non-depenendent =&gt;)...
pi : \{a:tp\} (vl a -&gt; tp) -&gt; tp.
# &gt; : tp -&gt; tp -&gt; tp = [A] [B] pi A [_]B.
  %infix right 120 =&gt;.

%% With one kind of observation on pi...
@ : \{x:vl A\}obs (B* x) C -&gt; obs (pi A B*) C.
  %infix right 120 @.

%% Now we define function abstraction...
fn : (\{x:vl A\}vl (B* x)) -&gt; vl (pi A B*).
fn/_ : body (fn E*) (V @ K) E'
	&lt;- body (E* V) K E'.

%% At this point, we could verify that body covers and is unique,
%% by uncommenting the following lines...
% %worlds () (body V C _).
% %covers body +V +C -E.
% %unique body +V +C -E.

%% Now we define *non-dependent* function application...
app-nd : vl (A =&gt; B) -&gt; vl A -&gt; vl B.
app-nd/_ : body (app-nd F V) C E'
	&lt;- body F (V @ C) E'.

%% Again, we could verify that body covers and is unique...
% %worlds () (body V C _).
% %covers body +V +C -E.
% %unique body +V +C -E.

%% However, now consider *dependent* function application,
%% with essentially the same body clause...
app : vl (pi A ([x]B* x)) -&gt; \{x:vl A\} vl (B* x).
app/_ : body (app F V) C E'
	&lt;- body F (V @ C) E'.

%% Suddenly, the coverage check fails...
% %worlds () (body V C _).
% %covers body +V +C -E.
% %unique body +V +C -E.
&lt;/code&gt;
Any ideas? Thanks, User:Noam|Noam]] 07:43, 19 September 2009 (EDT)

: Okay now I see that the problem is [Debugging_coverage_errors](/wiki/debugging-coverage-errors/). I don't quite understand what the suggested workaround is (is there an example somewhere?), but I figured out something, which may or may not amount to the same thing...

: Begin by defining a tp to internalize the LF application:
&lt;code&gt;
tapp : (vl A -&gt; tp) -&gt; vl A -&gt; tp.
t@ : obs (B* V) X -&gt; obs (tapp B* V) X.
&lt;/code&gt;
: Then assign app a type in terms of tapp, and give a slightly tweaked body clause:
&lt;code&gt;
app : vl (pi A ([x]B* x)) -&gt; \{x:vl A\} vl (tapp B* x).
app/_ : body (app F V) (t@ C) E'
	&lt;- body F (V @ C) E'.
&lt;/code&gt;
: Now this coverage checks! [User:Boyland](/wiki/user-boyland/) 15:37, 20 February 2010 (EST)

:Here is a relatively small example that indicates the problem:
&lt;twelf&gt;
%%%% Definitions

%% Define natural numbers

nat : type.

z : nat.
s : nat -&gt; nat.



%% Define terms

term : nat -&gt; type.

%abbrev t = term z.


lit : nat -&gt; t.


%% equality on terms

eq : term N1 -&gt; term N2 -&gt; type.


eq/ : eq T T.




%%% Variable levels and nolevel


var : term N -&gt; type.

%block blockvar : some \{n\} block \{t:term n\} \{v:var t\}.

% without this, we get a freezing violation: var would depend on var
fake : type.
- : (var X -&gt; var X') -&gt; fake.



%%% Variable lists


varlist : type.

varlist/0 : varlist.

varlist/+ : \{N\} \{V:term N\} var V -&gt; varlist -&gt; varlist.



%%% Operations on variable lists:


count : varlist -&gt; nat -&gt; nat -&gt; type.

lookup : varlist -&gt; term N -&gt; varlist -&gt; type.


count/0 : count varlist/0 N z.

count/= : count VL N M -&gt;
    count (varlist/+ N V _ VL) N (s M).


lookup/= : lookup (varlist/+ _ V _ VL) V VL.

lookup/!= :
	lookup VL V VL' -&gt;
    lookup (varlist/+ _ _ _ VL) V VL'.



%%% Theorems about operations on varlists.


%theorem count-independent:
	forall* \{N\} \{N'\} \{M\} \{VL\}
	forall	\{FC: \{v:term N\} (var v) -&gt; count VL N' M\}
	exists	\{C: count VL N' M\}
	true.

- : count-independent ([v] [i] count/0) count/0.

- : count-independent ([v] [i] count/= (FC v i)) (count/= C)
    &lt;- count-independent FC C.

%worlds (blockvar) (count-independent _ _).
%total (C) (count-independent C _).


%theorem lookup-count-independent:
	forall* \{N\} \{N'\} \{FVL\} \{FFVL'\} \{M\}
	forall	\{FFL: \{v': term N'\} \{i': var v'\} \{v: term N\} \{i: var v\}
		       lookup (FVL v i) v (FFVL' v' i' v i)\}
		\{FFC: \{v': term N'\} \{i': var v'\} \{v: term N\} \{i: var v\}
		       count (FFVL' v' i' v i) N M\}
	exists	\{FVL': \{v: term N\} \{i:var v\} varlist\}
                \{FL: \{v: term N\} \{i:var v\} lookup (FVL v i) v (FVL' v i)\}
		\{FC: \{v: term N\} \{i:var v\} count (FVL' v i) N M\}
	true.

- : lookup-count-independent ([v'] [i'] [v] [i] lookup/=) FFC _ ([v] [i] lookup/=) FC
    &lt;- (\{v\} \{i\} count-independent ([v'] [i'] FFC v' i' v i) (FC v i)).

- : lookup-count-independent ([v':term N'] [i':var v'] [v:term N] [i:var v] lookup/!= (FFL v' i' v i)) FFC ([v] [i] FVL v i)
     ([v:term N] [i:var v] lookup/!= (FL v i)) FC
    &lt;- lookup-count-independent FFL FFC _ FL FC.

%worlds (blockvar) (lookup-count-independent _ _ _ _ _).
%total (L) (lookup-count-independent L _ _ _ _).
&lt;/twelf&gt;
:: This code checks fine with the online version of Twelf.  It must be a problem with Twelf-CVS.
:: Update: The code still fails with the latest truck from SVN.  So it seems the online twelf checker has a different version than twelf-CVS/SVN.  older? [User:Boyland](/wiki/user-boyland/) 18:17, 22 February 2010 (EST)

#
# Termination and %mode

Hi Twelf Elf: I've just started getting into twelf and have been working my way through Frank Pfenning's Computation and Deduction notes  (http://www.cs.cmu.edu/~fp/courses/comp-ded/handouts/cd.pdf). I got so far as trying to get twelf to confirm that doubling 2 yields 4, but it gets stuck. (I'm also using the latest release of twelf, not the nightly build version.)

Below is my complete program; when I run it in twelf, it does not seem to terminate.

Any advice?

Thanks,
Robby

&lt;twelf discard=true&gt;
 exp : type.
 z : exp.
 s : exp -&gt; exp.
 case : exp -&gt; exp -&gt; (exp -&gt; exp) -&gt; exp.
 lam : (exp -&gt; exp) -&gt; exp.
 app : exp -&gt; exp -&gt; exp.
 fix : (exp -&gt; exp) -&gt; exp.

 eval : exp -&gt; exp -&gt; type.
 ev_z : eval z z.
 ev_s : eval E V -&gt; eval (s E) (s V).
 ev_case_z : eval E1 z -&gt; eval E2 V -&gt; eval (case E1 E2 ([y:exp] E3 y)) V.
 ev_case_s : eval E1 (s V1)
          -&gt; eval (E3 V1) V
          -&gt; eval (case E1 E2 E3) V.
 ev_lam : eval (lam F) (lam F).
 ev_app : eval E1 (lam F) -&gt; eval E2 V2 -&gt; eval (F V2) V -&gt; eval (app E1 E2) V.
 ev_fix : eval (E1 (fix E1)) V -&gt; eval (fix E1) V.

 double : exp = fix ([double : exp] 
 					  (lam [i : exp] 
 						 (case i
 							z 
 							([iminusone : exp] (s (s (app double iminusone))))))).
 
 %query 1 1 D : eval (app double (s z)) (s (s z)).
&lt;/twelf&gt;

---------

Hi Robby! Glad you're using Twelf. I'd definitely encourage you to use the "nightly build" - it's currently very stable and has lots of improvements (and fewer bugs) than the last release. Also, it's a good idea to sign your comment with four tildes &lt;nowiki&gt;~~~~&lt;/nowiki&gt; 

Anyway - I had a hunch, that turned out to be right, that the right thing to do was to write a ``[%mode](/wiki/percent-mode/)`` declaration ``%mode eval +E -V.``, which basically means "it makes sense to run ``eval`` as a function with input ``E`` and output ``V``. Sure enough, it complains about both the rule ``ev_case_s`` and ``ev_app``. If I reorder the premises so it no longer complains, the two rules look like this:
&lt;twelf&gt;
ev_case_s : eval (E3 V1) V
         -&gt; eval E1 (s V1)
         -&gt; eval (case E1 E2 E3) V.
ev_app : eval (F V2) V 
         -&gt; eval E2 V2 
         -&gt; eval E1 (lam F) 
         -&gt; eval (app E1 E2) V.
&lt;/twelf&gt;
In general, it's better to use backwards arrows when you intend to be running something as a logic program; the above program "looks better" written as this equivalent program:
&lt;twelf&gt;ev_case_s : eval (case E1 E2 E3) V
         &lt;- eval E1 (s V1)
         &lt;- eval (E3 V1) V.
ev_lam : eval (lam F) (lam F).
ev_app : eval (app E1 E2) V
         &lt;- eval E1 (lam F) 
         &lt;- eval E2 V2 
         &lt;- eval (F V2) V.
&lt;/twelf&gt;Good luck learning Twelf, let us know if we can help you in the future! — [User:rsimmons](/wiki/user-rsimmons/) (and his [User talk:rsimmons](/wiki/user-talk-rsimmons/)) 16:04, 1 November 2010 (EDT)
-------

Also, you can use this to run programs even if you don't know the answer:
&lt;twelf hidden=true import=modequestion&gt;
exp : type.
z : exp.
s : exp -&gt; exp.
case : exp -&gt; exp -&gt; (exp -&gt; exp) -&gt; exp.
lam : (exp -&gt; exp) -&gt; exp.
app : exp -&gt; exp -&gt; exp.
fix : (exp -&gt; exp) -&gt; exp.
eval : exp -&gt; exp -&gt; type.
ev_z : eval z z.
ev_s : eval E V -&gt; eval (s E) (s V).
ev_case_z : eval E1 z -&gt; eval E2 V -&gt; eval (case E1 E2 ([y:exp] E3 y)) V.
ev_case_s : eval (case E1 E2 E3) V
         &lt;- eval E1 (s V1)
         &lt;- eval (E3 V1) V.
ev_lam : eval (lam F) (lam F).
ev_app : eval (app E1 E2) V
         &lt;- eval E1 (lam F) 
         &lt;- eval E2 V2 
         &lt;- eval (F V2) V.
ev_fix : eval (E1 (fix E1)) V -&gt; eval (fix E1) V.
double : exp = 
  fix ([double : exp] 
    (lam [i : exp] 
      (case i z ([iminusone : exp] (s (s (app double iminusone))))))).
%mode eval +A -B.
&lt;/twelf&gt;
&lt;twelf import=modequestion check=decl&gt;
 %query 1 1 eval (app double (app double (app double (s (s (s z)))))) V.
&lt;/twelf&gt;&lt;twelflink import=modequestion&gt;See the corrected Twelf code along with this query&lt;/twelflink&gt; — [User:rsimmons](/wiki/user-rsimmons/) (and his [User talk:rsimmons](/wiki/user-talk-rsimmons/)) 16:14, 1 November 2010 (EDT)

-------

Thanks! I had read about %mode, and had even tried it with the definition of eval I posted above (getting the errors you allude to), but what I read about modes didn't suggest that ordering of the premises had any influence on the mode declaration. (Of course, I've now tried out your revision and sure enough I see that it does.). Is there more I should read about that? (So far I've just read 4.5 in _Computation and Deduction_.)

And yes, I do know how to run things without knowing the answer; of course it also didn't work for the example given. I put in the precise answer in a futile hope that that would help twelf terminate. Thanks also for the wiki advice. I'm amazed that it's taken me this long to post on one.... one question about wiki's tho: I had to come back here to see you'd posted. Is there a way to get email notification? (I had already clicked the "watch this page" checkbox.)

User:Robby|Robby]] 11:28, 2 November 2010 (EDT)

-------

I think this wiki has email turned off, actually. To understand the effect of %mode  you might find it helpful to read some general stuff about logic programming, which is where a lot of the intuition behind proving metatheorems comes from. — [User:rsimmons](/wiki/user-rsimmons/) (and his [User talk:rsimmons](/wiki/user-talk-rsimmons/)) 12:11, 4 November 2010 (EDT)

#
# POPL tutorial slides location?

The slides linked to from [POPL Tutorial](/wiki/popl-tutorial/) are 404. I tried to use Google to find the slides, but it was no help. User:Jbapple|Jbapple]] 15:09, 15 January 2011 (EST)

#
# Twelf 1.7.1 ?

It seems Twelf 1.7.1 is released, but the documentation still seems to be at 1.4
(with some wiki pages for 1.5 additions.)

(1) Is there any summary of changes since 1.4/1.5 ?

(2) Any plans to update the 1.4 documentation?

:: I don't know of any plans to do so (I think the wiki is now, for better or worse, the primary documentation). We should probably go through the wiki and turn some of the tags indicating "this is a SVN-only feature" to tags indicating "this is a Twelf 1.7 feature," though. There is a [revision history](/wiki/release-history/) on the wiki. — [User:rsimmons](/wiki/user-rsimmons/) (and his [User talk:rsimmons](/wiki/user-talk-rsimmons/)) 21:33, 24 August 2011 (EDT)

#
# Problem to find an induction metric

I would like to prove that if two numbers are the same, e.g., N0 = N1, then, if I set the K-th position of a list to N0, or to N1, I get the same resulting list. The proof is not obvious to me because I cannot, in this case, do induction on the derivation rules of lists. I have these signatures for numbers:

&lt;twelf&gt;
nat   : type.
z     : nat.
s     : nat -&gt; nat.

% eq N1 N2 is true if N1 and N2 represent the same number.
eq : nat -&gt; nat -&gt; type.
%mode eq +N1 +N2.
eq_z : eq z z.
eq_s : eq (s N1) (s N2)
    &lt;- eq N1 N2.
%worlds () (eq N1 N2).
%terminates \{N1 N2\} (eq N1 N2).
&lt;/twelf&gt;

And these signatures for the list:

&lt;twelf&gt;
list : type.
element : type.
nil : list.
con : element -&gt; list -&gt; list.
value : nat -&gt; element.

% set L E N L' == L' is the same list as L, except that its N-th cell has
% been set to E.
set : list -&gt; element -&gt; nat -&gt; list -&gt; type.
%mode set +L +E +N -L'.
set_z : set (con E' EL) E z (con E EL).
set_s : set (con E' L) E (s N) (con E' L')
    &lt;- set L E N L'.
&lt;/twelf&gt;

And below is the theorem that I would like to prove:

&lt;twelf&gt;
eq_set : eq N N' -&gt; set L (value N') V L' -&gt; set L (value N) V L' -&gt; type.
%mode eq_set +Eq +Set' -Set.

eq_set_z : eq_set eq_z Set Set.
% eq_set_s ???

%worlds () (eq_set _ _ _).
%total Eq (eq_set Eq _ _).
&lt;/twelf&gt;

:: I think you need to determine an equality judgment on L', and prove 
&lt;twelf&gt;
        eq_set : eq N N' -&gt; set L (value N') V L' -&gt; set L (value N) V L' -&gt; eq-list L L' -&gt; type.
        %mode eq_set +Eq +Set' +Set -Eq'.
&lt;/twelf&gt;
:: Does that help at all? — [User:rsimmons](/wiki/user-rsimmons/) (and his [User talk:rsimmons](/wiki/user-talk-rsimmons/)) 16:55, 18 June 2012 (EDT)

#
# trouble with twelf server

Hi,

Im doing my final year project on LF and imperative languages and Ive decided to use Twelf to mechanize the theory, however, I'm finding it difficult to start the server on Linux, while on OsX had no problem. Please help. I've dwnloaded the pre-installed Linux version on Ubuntu and straight away I call bin/twelf-server, however this error comes up:

@ubuntu:~/twelf$ bin/twelf-server 
bin/twelf-server: error while loading shared libraries: libgmp.so.3: cannot open shared object file: No such file or directory

What am I missing? For what ive understood I do not need to use Make as is pre-installed, right? So I should be a ble to run it from scratch....

Looking forward to hear from you,
J. Dominguez


:: Sorry for not noticing this before; the MLton-compiled binary depends on the GMP BigNum library, which you should be able to get with apt-get on ubuntu. — [User:rsimmons](/wiki/user-rsimmons/) (and his [User talk:rsimmons](/wiki/user-talk-rsimmons/)) 16:52, 18 June 2012 (EDT)

#
# How to prove totality in this case?

I am formalizing a programming language. One of the things I need is a conditional statement and prove its totality (this is needed for dynamic semantics, that has to search through an associative list, and the keys have decidable equality). I can do a simple one, like this:

&lt;pre&gt;
bool : type.
true : bool.
false : bool.

% my language has expressions and computations
expr : type.
comp : type.

% lambda abstraction and injection of expressions into computations create a headache later on
fun : (expr -&gt; comp) -&gt; expr.
val : comp -&gt; expr.

cond-expr : bool -&gt; expr -&gt; expr -&gt; expr -&gt; type.
%mode cond-expr +B +E +E' -E_.

- : cond-expr true E _ E.
- : cond-expr false _ E' E'.

%worlds () (cond-expr _ _ _ _).
%total \{B E E'\} (cond-expr B E E' _).
&lt;/pre&gt;

So far so good. But I actually need a slightly more complicated conditional:

&lt;pre&gt;
%abbrev cow = (expr -&gt; (expr -&gt; comp) -&gt; comp).

cond-cow : bool -&gt; cow -&gt; cow -&gt; cow -&gt; type.
%mode cond-cow +B +Moo +Moo' -Moo_.

- : cond-cow true Moo _ Moo.
- : cond-cow false _ Moo' Moo'.
&lt;/pre&gt;

Now suppose we want to check totality of &lt;code&gt;cond-cow&lt;/code&gt;:

&lt;pre&gt;
%worlds () (cond-cow _ _ _ _).
%total \{B Moo Moo'\} (cond-cow B Moo Moo' _).
&lt;/pre&gt;

Then we get this error message:
&lt;pre&gt;
While checking constant %-%:
Family expr has no worlds declaration
%% ABORT %%
&lt;/pre&gt;

So one would like to add &lt;code&gt;%worlds&lt;/code&gt; for &lt;code&gt;expr&lt;/code&gt; and &lt;code&gt;comp&lt;/code&gt;. But if I try something like
&lt;pre&gt;
%worlds () (expr).
%worlds () (comp).
&lt;/pre&gt;
I get "&lt;code&gt;comp&lt;/code&gt; would depend on &lt;code&gt;expr&lt;/code&gt;".  And I think that &lt;code&gt;val&lt;/code&gt; and &lt;code&gt;fun&lt;/code&gt; can be a further source of trouble. 

I am stumped. Why is it even analyzing &lt;code&gt;cow&lt;/code&gt;? What is Twelf thinking and how to I fix it?

Thanks! Andrej Bauer (please notify me by email about the answer at Andrej.Bauer@andrej.com)

: I think you need to declare the worlds of both expr and comp together as in
&lt;pre&gt;
%worlds () (expr) (comp).
&lt;/pre&gt;
: [User:Boyland](/wiki/user-boyland/) 15:28, 5 June 2013 (EDT)

#
# %reduces not as smart as what is done in %total, it seems

I don't see a way to prove %reduces through a lambda abstraction,
although, it appears that %total checking is able to reason about
these.  For example:

&lt;twelf&gt;
%% HOAS for LC

t : type.

lam : (t -&gt; t) -&gt; t.

app : t -&gt; t -&gt; t.


m : t -&gt; t -&gt; type.

m/0 : m T T.

m/app1 : m T1 T2 -&gt; m (app T1 _) T2.

m/app2 : m T1 T2 -&gt; m (app _ T1) T2.

m/lam : (\{x\} m (F x) T) -&gt; m (lam ([x] F x)) T.

%reduces T2 &lt;= T1 (m T1 T2).
&lt;/twelf&gt;

This gives error

Reduction violation:
Pi (T) &lt;= (F x) ---&gt; (T) &lt;= (lam ([x:t] F x))

Is there a workaround to this problem?
[User:Boyland](/wiki/user-boyland/) 05:07, 3 October 2013 (EDT)

:: What's an example where this works for %total?

Here's one that checks just fine: [User:Boyland](/wiki/user-boyland/) 08:51, 11 October 2013 (EDT)
&lt;twelf&gt;

nat : type.

z : nat.

s : nat -&gt; nat.

max : nat -&gt; nat -&gt; nat -&gt; type.
%mode max +N1 +N2 -N3.

max/zz : max z z z.

max/sz : max (s N) z (s N).

max/zs : max z (s N) (s N).

max/ss : max N1 N2 N3 -&gt; max (s N1) (s N2) (s N3). 

%worlds () (max _ _ _).
%total (N) (max N _ _).


height : t -&gt; nat -&gt; type.
%mode height +T -N.

%block hb : block \{x\} \{h:height x z\}.

height/lam : (\{x\} (height x z) -&gt; height (F x) N) -&gt; height (lam F) (s N).

height/app : height (app T1 T2) (s N3)
    &lt;- height T1 N1
    &lt;- height T2 N2
    &lt;- max N1 N2 N3.

%worlds (hb) (height _ _).
%total (T) (height T _).
&lt;/twelf&gt;

#
# dictionary in which keys are variable names

Dear Elfs,

We are using Twelf for implementing a language semantics. We have typing judgement of the form:

Γ |- e : τ : Ω

- Γ is the context
- e is the expression
- τ is the type
-  Ω is a set of relations between variables in e and a label

For this typing judgement, we would like to have the following mode: 

%mode of +E -T -L.

For instance:

x : int, y: int |- x + y + 1 : int : \{x:low, y: high\} 

In our typing semantics, we have some rules that modifies Ω and others that retrieve a label given a specific variable name. 

To implement this, we have 2 options:
- implement a complex way to deal with variables which means redefining substitution and so on (very tedious)
- use twelf variables in our expression to write expressions such as "λx:int.x" as "lambda int ([x] x)" but we need an elfy magic trick to implement Ω

Do you have examples or ideas about how to implement some sort of dictionary in which keys are actual variable names?  

I hope all of this was clear. 

Thank you. 

Thierry

: Either way should be possible.  
:If you implement explicit (non-LF) variables, then as you say, you need to define substitution etc yourself, which is a pain.  But you can use the set/map types in my Twelf library.
:Otherwise, trying to implement a true ("adequate") map from variables to sets of labels is very tricky.  It can be done but will pollute your context with tons of extra things.  See [HOAS nat bijection](/wiki/hoas-nat-bijection/).
:The big problem is "inequality".  It's very difficult to determine if two variables are equal or not in Twelf.
:[User:Boyland](/wiki/user-boyland/) 11:02, 13 January 2014 (EST)

#
# Twelf bug reports?

Is Twelf still being maintained?  I have a (BIG) example where type reconstruction doesn't terminate in Twelf 1.7.1+ (r1887M).  Is anyone interested in bug reports?

#
# Syntax highlighting for IntelliJ IDEA

Good evening Twelf Elf, 

I have created an IntelliJ plugin for Twelf which can be downloaded from the IntelliJ plugin repository: 
http://plugins.jetbrains.com/plugin/7533

The source code is also available on Github:  
https://github.com/alahijani/Jelf

You can download IntelliJ IDEA community edition from: 
http://www.jetbrains.com/idea/download/

Sorry, I could not find a publicly editable notice board. Is there a place where I can post instructions?

User:Ali|Ali]] 02:23, 19 August 2014 (EDT)

#
# Problems with pages

See for example [Lax logic](/wiki/lax-logic/) where errors reported with: "Failed to parse (PNG conversion failed; check for correct installation of latex, dvips, gs, and convert)" occur very frequently.

User:Fairflow|Fairflow]] 04:11, 9 December 2014 (EST)

I don't see the problem.  Perhaps (1) it has been rsolved, or (2) it may be browser related?
[User:Boyland](/wiki/user-boyland/) ([User talk:Boyland](/wiki/user-talk-boyland/)) 21:00, 21 October 2016 (UTC)

#
# Can’t solve obvious goal or is it me?

I’m new to Twelf (have to see it matches what I’m planning to do).

Testing the very simple sample below:

    nat : type.
    z : nat.
    s : nat -&gt; nat.
    sum : nat -&gt; nat -&gt; nat -&gt; type.
    sum/z : sum z N N.
    sum/s : sum M (s N) (s S) &lt;- sum M N S.

Then querying this:

    %query 1 * sum (s z) (s z) X.

It fails. While if `sum/s` is changed from `sum/s : sum M (s N) (s S) &lt;- sum M N S.` to `sum/s : sum (s M) N (s S) &lt;- sum M N S.` it works.

Unless I’m wrong, the goal should be as much solvable is both case. Is this me missing something?

#
# Twelf pre-built Mac OS distro needs update

Dear Twelf Elves,

Mac OS X Catalina deprecated running 32-bit apps, and the pre-built Mac OSX distro of Twelf does not work anymore.
(Building from source with SMLNJ still works.)

Could this be updated?

Thanks.
!}%
