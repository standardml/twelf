%%! title: "Deterministic declaration"

%{!
The **``%determinstic``** declaration influences the way [logic programming](/wiki/logic-programming/) behaves in Twelf. If a type family is deterministic, then once Twelf finds a single solution through logic programming search it cannot backtrack to find different solutions.

#
# Example: Tree search

[[Image:Smalltree.svg|thumb|right|250px|Graphical representation of the tree ``testtree`` used in this example.]]
We define a tree with labeled nodes, and a distinguished tree ``testtree`` 
&lt;twelf&gt;
label : type.
a : label.
b : label.
c : label.
d : label.

tree : type.
node : tree -&gt; tree -&gt; tree.
leaf : label -&gt; tree.

testtree = node (node (leaf a) (leaf b)) (node (leaf c) (leaf d)).
&lt;/twelf&gt;

#
#
# Searching for a leaf

We also define a judgment, ``findlabel``, that looks for a label at leaves of the tree. Because Twelf tries to use the first-defined rule first, the operational behavior of this is to search for the leftmost node, then to backtrack and find the next-to-leftmost node, etc.

&lt;twelf&gt;
findlabel : tree -&gt; label -&gt; type.
findlabel/leaf : findlabel (leaf L) L.
findlabel/left : findlabel (node T1 T2) L
                  &lt;- findlabel T1 L.
findlabel/right : findlabel (node T1 T2) L
                  &lt;- findlabel T2 L.
&lt;/twelf&gt;

If ``findlabel`` is not declared deterministic, all four solutions can be returned, but with ``findlabel`` declared deterministic only one will be found.

&lt;twelf check=decl discard=true&gt;
%query 4 * findlabel testtree L.
&lt;/twelf&gt;

&lt;twelf check=decl discard=true&gt;
%deterministic findlabel.
%query 1 * findlabel testtree L.
&lt;/twelf&gt;


#
#
# Causing search to fail

When using **``%deterministic``**, finite failure]] no longer means that no derivation can be found, becuase the deterministic search may put constraints on later results that causes them to fail. Take the ``searchfor`` predicate, which first looks up a label with ``findlabel`` and then checks to see if it is equal to some other label.

&lt;twelf&gt;
eq : label -&gt; label -&gt; type.
eq/refl : eq L L.

searchfor : tree -&gt; label -&gt; type.
- : searchfor T L
     &lt;- findlabel T L'
     &lt;- eq L L'.
&lt;/twelf&gt;

Using ``searchfor`` to look for ``c`` in our test tree will cause backtracking, because ``findlabel`` first make ``L'`` equal to ``a``, then ``b``, then ``c``.

&lt;twelf check=decl discard=true&gt;
%query 1 * P : searchfor testtree c.
&lt;/twelf&gt;

If ``findlabel`` is deterministic, then the same search will make ``L'`` equal ``a``, and will then be unable to backtrack.

&lt;twelf check=decl discard=true&gt;
%deterministic findlabel.
%query 1 * P : searchfor testtree c.
&lt;/twelf&gt;

#
# See also

* \{\{guide|title=Deterministic Type Families|chapter=5|section=30\}\}
* w:Cut (logic programming)|Cut]] on Wikipedia

\{\{keyword|key=deterministic\}\}
!}%
